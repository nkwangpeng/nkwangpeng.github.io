<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>分治算法求最邻近点对问题 | WangPeng's Blog</title><meta name="description" content="分治算法求最邻近点对问题"><meta name="keywords" content="算法"><meta name="author" content="Wang Peng"><meta name="copyright" content="Wang Peng"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="分治算法求最邻近点对问题"><meta name="twitter:description" content="分治算法求最邻近点对问题"><meta name="twitter:image" content="https://nkwangpeng.github.io/img/Closest_Point.png"><meta property="og:type" content="article"><meta property="og:title" content="分治算法求最邻近点对问题"><meta property="og:url" content="https://nkwangpeng.github.io/2020/04/14/Closet-Point/"><meta property="og:site_name" content="WangPeng's Blog"><meta property="og:description" content="分治算法求最邻近点对问题"><meta property="og:image" content="https://nkwangpeng.github.io/img/Closest_Point.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://nkwangpeng.github.io/2020/04/14/Closet-Point/"><link rel="next" title="Hexo+Github 搭建个人博客" href="https://nkwangpeng.github.io/2020/04/11/hexo-Github/hexo-Github/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="WangPeng's Blog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">3</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">2</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/Music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#问题描述"><span class="toc-number">1.</span> <span class="toc-text">问题描述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#"><span class="toc-number">1.0.1.</span> <span class="toc-text"> 首先声明图源自网络 (侵删)。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#问题分析"><span class="toc-number">2.</span> <span class="toc-text">问题分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#暴力求解"><span class="toc-number">2.1.</span> <span class="toc-text">暴力求解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分治法求解"><span class="toc-number">2.2.</span> <span class="toc-text">分治法求解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分治法的时间复杂度分析"><span class="toc-number">2.3.</span> <span class="toc-text">分治法的时间复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#代码清单"><span class="toc-number">3.</span> <span class="toc-text">代码清单</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#感谢观看"><span class="toc-number">4.</span> <span class="toc-text">感谢观看</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/categories.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">WangPeng's Blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/Music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">分治算法求最邻近点对问题</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-04-14 16:51:51"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-14</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-04-14 18:30:23"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-04-14</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h3> 首先声明图源自网络 (侵删)。</h3>

<p>要求用分治算法（O (nlogn) 复杂度）实现寻找 n 个点中最邻近点对，输出最近距离的平方。<br>数据输入:<br>第一行表示点的数目 n；<br>接下来的 n 行中，每一行依次表示点的 x 坐标，y 坐标。<br>结果输出:<br>输出 n 个点中最邻近点对距离的平方 (小数点后两位) 输入示例：<br>8<br>1 1<br>2 2<br>4 4<br>8 8<br>2 2.8<br>5 6<br>7 9<br>11 11 输出示例： 0.64 </p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><p>如果我们暴力求解的话。对于第一个点会与其他 n-1 个点比较，第二个点会与其他 n-2 个点比较，第 n-1 个点会与 1 个点比较。因此复杂度为 1+2+・・・+n-1=O (n^2)。</p>
<h2 id="分治法求解"><a href="#分治法求解" class="headerlink" title="分治法求解"></a>分治法求解</h2><p>分治法的思路是首先将输入的 n 个点分别按照 x 坐标升序排序存到 Point X 中，y 坐标升序排序存到 Point Y 中。值得一提的是这里我用的是 STL 库函数中的 sort 函数，而我查阅了相关资料库函数中的 sort 函数采用的是快速排序 (数据量小时用的是插入排序，数据量大时用的是堆排序)。那么有的同学可能会问，既然数据量小的时候用的是插入排序，复杂度怎么会是 O (nlogn) 呢？那这里我们就要考虑实际问题了，分治算法的应用场景是数据量大时，因此采用的是堆排序，即 O (nlogn)。<br>之后选取 x=m 来作为分割直线。其中 m 为点集 S 中各点 x 坐标的中位数即 X [length/2]。由此将 S 分割为两部分 S1 和 S2。递归地在 S1 和 S2 上解最接近点对问题，我们分别得到 S1 和 S2 中的最小距离 d1 和 d2。现设 d=min (d1,d2)，但是这时的 d 并不是所求的最临近点对距离，因为可能在分界线左右长度为 d 的范围内可能存在一左一右的点距离小于 d。<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/04/14/JSt4v8.png"  alt><br>对于 P1 中任意一点 p, 若他与 P2 中的点 q 有 distance (p,q) 小于 d。那么满足这个条件的 P2 中的点有多少个呢？我们容易看出这样的点一定落在一个 d×2d 的矩形 R 中，如下图所示:<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/04/14/JSNeKO.png"  alt><br>我们将右半部分即 P2 分成六等份，如下图所示。易得每一个空格里至多有一个点。倘若一个空格里存在了两个点，那么这两点间的距离最大为 (d/2)^2+(2d/3)^2=(25d^2)/36 小于 d，那么 d 就不再是最短的距离了，因此六个空格最多存在六个点。理所应当，对于中间区域的任何一点，最多与上下总共 6 个点比较即可 (按 y 坐标升序排序)<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/04/14/JSaruT.png"  alt></p>
<h2 id="分治法的时间复杂度分析"><a href="#分治法的时间复杂度分析" class="headerlink" title="分治法的时间复杂度分析"></a>分治法的时间复杂度分析</h2><p>首先我们初始时进行了两次排序复杂度为 O (nlogn)+O (nlogn)，之后在分治算法递归过程中每次将工作 n 分为左右两部分，左右两部分工作量为 n/2，合并时由于每个点只需要比较六个点，因此合并时候的复杂度为 O (n)，即有 T (n)=2T (n/2)+O (n)=&gt;T (n)=O (nlogn)。因此总的时间复杂度就为 O (nlogn)。</p>
<h1 id="代码清单"><a href="#代码清单" class="headerlink" title="代码清单"></a>代码清单</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span>   // 定义坐标点类 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">float</span> x;</span><br><span class="line">	<span class="keyword">float</span> y;</span><br><span class="line">	<span class="built_in">point</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">point</span>(<span class="keyword">float</span> x, <span class="keyword">float</span> y) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">		<span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">point</span>*X, *Y;     <span class="comment">// 设置全局变量点集 X (Y) 用于存放按 x (y) 坐标排序的点 </span></span><br><span class="line"><span class="keyword">int</span> n;			<span class="comment">// 用户输入数据的组数 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compx</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span>  <span class="comment">// 比大小函数 STL 库中 sort 函数有 3 个参数 (start,end,compare 函数名)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compy</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span>  <span class="comment">// 同上 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">distance</span><span class="params">(<span class="built_in">point</span> a, <span class="built_in">point</span> b)</span>  <span class="comment">// 返回两点间距离函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">find_distance_min</span><span class="params">(<span class="keyword">int</span> <span class="built_in">begin</span>,<span class="keyword">int</span> <span class="built_in">end</span>)</span> <span class="comment">// 分治算法具体实现 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> length = <span class="built_in">end</span> - <span class="built_in">begin</span> + <span class="number">1</span>;           <span class="comment">// 记录用户输入的 n 值 </span></span><br><span class="line">	<span class="keyword">if</span> (length == <span class="number">1</span>) &#123; <span class="keyword">return</span> INFINITY; &#125;    <span class="comment">// 如果只有一个点，则距离为无穷 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (length == <span class="number">2</span>) &#123; <span class="keyword">return</span> distance (X [<span class="built_in">begin</span>], X [<span class="built_in">end</span>]); &#125; <span class="comment">// 如果只有两个点，则为这两点距离 </span></span><br><span class="line">	<span class="keyword">else</span> &#123;       <span class="comment">// 如果有三个点以上，就使用分治策略 </span></span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt;S;   <span class="comment">// 存放中间区域 2d 之间的点 </span></span><br><span class="line">		<span class="keyword">float</span> min_left = find_distance_min (<span class="built_in">begin</span>, <span class="built_in">begin</span> + length/ <span class="number">2</span> - <span class="number">1</span>); <span class="comment">// 递归左部分最近距离 </span></span><br><span class="line">		<span class="keyword">float</span> min_right = find_distance_min (<span class="built_in">begin</span> + length / <span class="number">2</span>, <span class="built_in">end</span>);  <span class="comment">// 递归右部分最近距离 </span></span><br><span class="line">		<span class="keyword">float</span> min_side = min_left &lt; min_right ? min_left : min_right;  <span class="comment">// 记录左右部分最近距离 </span></span><br><span class="line">		<span class="keyword">float</span> mid_x = X [length / <span class="number">2</span>].x;    <span class="comment">// 中位数用于寻找在中间区域 2d 之间的点 </span></span><br><span class="line">		<span class="keyword">float</span> <span class="built_in">min</span> = min_side;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">abs</span>(Y [i].x - mid_x) &lt; min_side) S.push_back (Y [i]); <span class="comment">// 在中间区域 2d 之间的点加入 S</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>();i++)   <span class="comment">// 遍历 S 其中的点 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;S.<span class="built_in">size</span>()&amp;&amp; (S [j].y - S [i].y) &lt; min_side; j++)<span class="comment">// 只比较那些按 y 坐标排序距离小于 d 的点 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">min</span> = <span class="built_in">min</span> &gt; distance (S [i], S [j]) ? distance (S [i], S [j]) : <span class="built_in">min</span>; <span class="comment">// 更新 min 值 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	X = <span class="keyword">new</span> <span class="built_in">point</span>[n];</span><br><span class="line">	Y= <span class="keyword">new</span> <span class="built_in">point</span>[n];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 用户输入 </span></span><br><span class="line">		<span class="keyword">float</span> a, b;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a&gt;&gt;b;</span><br><span class="line">		<span class="function"><span class="built_in">point</span> <span class="title">z</span><span class="params">(a, b)</span></span>;</span><br><span class="line">		X [i] = Y [i] = z;</span><br><span class="line">	&#125;</span><br><span class="line">	sort (X, X + n, compx); <span class="comment">// 按 x 坐标排序 </span></span><br><span class="line">	sort (Y, Y + n, compy); <span class="comment">// 按 y 坐标排序 </span></span><br><span class="line">	<span class="keyword">float</span> <span class="built_in">min</span> = find_distance_min (<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">min</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="感谢观看"><a href="#感谢观看" class="headerlink" title="感谢观看"></a>感谢观看</h1></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wang Peng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nkwangpeng.github.io/2020/04/14/Closet-Point/">https://nkwangpeng.github.io/2020/04/14/Closet-Point/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nkwangpeng.github.io" target="_blank">WangPeng's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="/img/Closest_Point.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/04/11/hexo-Github/hexo-Github/"><img class="next_cover lazyload" data-src="/img/hexo+github.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hexo+Github 搭建个人博客</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(/img/categories.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Wang Peng</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js" ></script><script src="/js/utils.js" ></script><script src="/js/main.js" ></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/click_heart.js"></script></body></html>